////////////////////////////////////////
//// Реализация через OfficeOpenXML ////
////////////////////////////////////////

////Чтение через XML////
Функция хмл_ПрочитатьЛистВТаблицуЗначений(ФайлEXCEL, ИмяНомерЛиста, СтрокаЗаголовка = 1, НачСтрока = 0, КонСтрока = 0, КонКолонка = 0) Экспорт
       
    ФайлНомерЛиста  = ИмяНомерЛиста.НомерЛиста;
    ФайлНомерЛиста = ?(ФайлНомерЛиста = 0, 1, ФайлНомерЛиста);
   
    ZIPКаталог = КаталогВременныхФайлов() + "XLSX\";	
	ОтветРаспаковки = хмл_ИзвлечьXLSXВКаталогZIP(ФайлEXCEL, ZIPКаталог);
	Если ОтветРаспаковки.Результат = Ложь Тогда
		Возврат Новый ТаблицаЗначений;
	КонецЕсли;
	
    СоответствиеNumFmtIdFormatCode = Новый Соответствие;
    МассивNumFmtId = хмл_ИзвлечьДанныеИзФайла_StylesXML(ZIPКаталог, СоответствиеNumFmtIdFormatCode);
   
    МассивSharedStrings = хмл_ИзвлечьДанныеИзФайла_SharedStringsXML(ZIPКаталог);
   
    SheetX = Новый ЧтениеXML;
    SheetX.ОткрытьФайл(ZIPКаталог + "XL\WorkSheets\Sheet" + ФайлНомерЛиста + ".xml");
   
    МассивИменКолонокXLSX = хмл_ПолучитьМассивИменКолонокНаЛистеXLSX(SheetX);
    КолвоКолонокEXCEL = МассивИменКолонокXLSX.Количество();
		
    // Создание результирующей таблицы, в которую будут записываться считанные из EXCEL данные.
    ТаблицаРезультат = Новый ТаблицаЗначений;
    // Формирование колонок результирующей таблицы.
    // "НомерСтроки" - для наглядности и удобства.
    // В зависимости от разрабатываемой обработки.
    // "Сопоставлено" - может быть другим.
    // Здесь же могут быть добавлены другие колонки, не формируемые из содержимого файла EXCEL.
    ТаблицаРезультат.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"), "№", 4);
    ТаблицаРезультат.Колонки.Добавить("Сопоставлено", Новый ОписаниеТипов("Булево"), "Сопоставлено", 1);
    ТаблицаРезультат.Колонки.Добавить("УровеньГруппировки", Новый ОписаниеТипов("Число"), "Гр", 2); // Группировка строк в файле EXCEL.
    Для ит = 1 ПО КолвоКолонокExcel Цикл
        ИмяКолонки = "N" + ит;
        Колонка = ТаблицаРезультат.Колонки.Добавить(ИмяКолонки);
    КонецЦикла;
   
    SheetX = Новый ЧтениеXML;
    SheetX.ОткрытьФайл(ZIPКаталог + "XL\WorkSheets\Sheet" + ФайлНомерЛиста + ".xml");
   
    ЭтоНачалоДанных = Ложь;
    // Считать очередной узел XML.
    Пока SheetX.Прочитать() Цикл
        Если ВРег(SheetX.Имя) = "SHEETDATA" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            ЭтоНачалоДанных = Истина;
            Прервать;
        КонецЕсли;
    КонецЦикла;
    Если НЕ ЭтоНачалоДанных Тогда
        Возврат Новый ТаблицаЗначений;
    КонецЕсли;
   
    // Считать очередной узел XML.
    НомерСтроки = 0;
    Пока SheetX.Прочитать() Цикл
        Если ВРег(SheetX.Имя) = "SHEETDATA" И SheetX.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
            Прервать;   // Окончание данных.
        КонецЕсли;
        Если ВРег(SheetX.Имя) = "ROW" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            НомерСтроки = НомерСтроки + 1;
            Если НЕ НачСтрока = 0 И НомерСтроки < НачСтрока Тогда
                Продолжить;
            КонецЕсли;
            НоваяСтрока = ТаблицаРезультат.Добавить();
            НоваяСтрока.НомерСтроки = НомерСтроки;
            НоваяСтрока.УровеньГруппировки = SheetX.ЗначениеАтрибута("outlineLevel");
            Пока SheetX.Прочитать() Цикл    // Считаем колонки строки EXCEL.
                Если ВРег(SheetX.Имя) = "ROW" Тогда
                    Прервать;
                КонецЕсли;
                Если ВРег(SheetX.Имя) = "SHEETDATA" И SheetX.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
                    Прервать;   // Окончание данных.
                КонецЕсли;
                Если ВРег(SheetX.Имя) = "C" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                    ТипЗначения = SheetX.ЗначениеАтрибута("t");
                    ФорматЯчейки = SheetX.ЗначениеАтрибута("s");
                    ИмяКолонки = SheetX.ЗначениеАтрибута("r");
                    ИмяКолонкиБезЦифр = хмл_ЗаменитьОдниСимволыДругими("0123456789", ИмяКолонки, "");
                    ИндексКолонки = МассивИменКолонокXLSX.Найти(ИмяКолонкиБезЦифр)+1;
					
					//
					Если КонКолонка <> 0 И ИндексКолонки > КонКолонка Тогда
						Пока SheetX.Прочитать() Цикл
							Если ВРег(SheetX.Имя) = "ROW" Тогда
								Прервать;
							КонецЕсли;	
						КонецЦикла;
						Прервать;
					КонецЕсли;
					//
					
					SheetX.Прочитать();
                    Если ВРег(SheetX.Имя) = "V"  ИЛИ ВРег(SheetX.Имя) = "F" Тогда   // "V" - Значение, "F" - Формула.
                        Если ВРег(SheetX.Имя) = "F" Тогда
                            Пока НЕ ВРег(SheetX.Имя) = "V" Цикл
                                SheetX.Прочитать();
                            КонецЦикла;
                        КонецЕсли;
                        SheetX.Прочитать();
                        Если ВРег(SheetX.Имя) = "#TEXT" Тогда
                            ЗначениеЯчейки = SheetX.Значение;
                            ФорматСтиля = "";
                            Если (НЕ ФорматЯчейки = "" И НЕ ФорматЯчейки = Неопределено) Тогда
                                Попытка
                                    ИндексФормата = Число(ФорматЯчейки);
                                    ФорматСтиля = СоответствиеNumFmtIdFormatCode.Получить(МассивNumFmtId[ИндексФормата]);
                                Исключение
                                    ФорматСтиля = "";
                                КонецПопытки;
                            КонецЕсли;
                            Если ЗначениеЗаполнено(ЗначениеЯчейки) Тогда
                                Если ТипЗначения = Неопределено ИЛИ ВРег(ТипЗначения) = "N" ИЛИ ВРег(ТипЗначения) = "B" Тогда
                                    Попытка
                                        Значение1 = Число(ЗначениеЯчейки);
                                    Исключение
                                        Значение1 = ЗначениеЯчейки;
                                    КонецПопытки;
                                    ЗначениеЯчейки = Значение1;
                                    Если (ФорматСтиля = "" ИЛИ ФорматСтиля = Неопределено) Тогда
                                        // ФорматСтиля = Неопределено - Атрибут "s" отсутствует.
                                        // MS Office (2010) может не формировать в xml-файле описание стиля форматирования для ячейки.
                                        // LibreOffice (4.1.5) формирует в xml-файле необходимые описания стиля форматирования ячейки.
                                        // Сообщить("Не определен стиль форматирования для кода " + ФорматЯчейки + " значения " + ЗначениеЯчейки);
                                    КонецЕсли;
                                   
                                    Если ТипЗнч(ЗначениеЯчейки) = Тип("Строка")
                                        И (Найти(ЗначениеЯчейки, "E-") > 0 ИЛИ Найти(ЗначениеЯчейки, "E+") > 0) Тогда
                                        ЗначениеЯчейки = хмл_ПолучитьЧислоВСтепениИзСтроковогоЗначения(ЗначениеЯчейки);
                                    КонецЕсли;
                                   
                                    Если ТипЗнч(ЗначениеЯчейки) = Тип("Число") Тогда
                                        // ПРОЦЕНТ.
                                        Если хмл_ЭтоПроцентXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
                                            ЗначениеЯчейки = Окр(ЗначениеЯчейки * 100, 3);
                                        // БУЛЕВО.
                                        ИначеЕсли хмл_ЭтоБулевоXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
                                            ЗначениеЯчейки = Булево(ЗначениеЯчейки);
                                        // ВРЕМЯ.
                                        ИначеЕсли хмл_ЭтоВремяXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
                                            ЗначениеЯчейки = хмл_КонвертироватьЧислоXLSXвДатуВремя(ЗначениеЯчейки);
                                        // ДАТА.
                                        ИначеЕсли хмл_ЭтоДатаXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
                                            ЗначениеЯчейки = хмл_КонвертироватьЧислоXLSXвДату(ЗначениеЯчейки);
                                        // ЧИСЛО.
                                        ИначеЕсли ТипЗначения = Неопределено
                                            ИЛИ ( хмл_ЭтоЧислоXLSX(ЗначениеЯчейки, ФорматСтиля)
                                            И НЕ хмл_ЭтоБулевоXLSX(ЗначениеЯчейки, ФорматСтиля)
                                            И НЕ хмл_ЭтоВремяXLSX(ЗначениеЯчейки, ФорматСтиля)
                                            И НЕ хмл_ЭтоДатаXLSX(ЗначениеЯчейки, ФорматСтиля) )
                                            Тогда
                                            // Без преобразования.
                                        Иначе
                                            // Прочие форматы.
                                        КонецЕсли;
                                       
                                    Иначе
                                       
                                        Сообщить("Не удалось преобразовать значение к ""числовому""(процент, время, дата, число) типу.");
                                       
                                    КонецЕсли;
                                   
                                ИначеЕсли ВРег(ТипЗначения) = "S" Тогда
                                   
                                    // МассивSharedStrings может быть пустым.
                                    Попытка
                                        ЗначениеЯчейки = СокрЛП(МассивSharedStrings[Число(SheetX.Значение)]);
                                    Исключение
                                        ЗначениеЯчейки = "";
                                    КонецПопытки;
                                   
                                ИначеЕсли ВРег(ТипЗначения) = "STR" Тогда
                       
                                    Если ТипЗнч(ЗначениеЯчейки) = Тип("Строка") Тогда
                                        ЗначениеЯчейки = СокрЛП(ЗначениеЯчейки);
                                    КонецЕсли;
                       
                                КонецЕсли;
                            КонецЕсли;
                           
                            ИмяКолонки = "N"+ИндексКолонки;
                            НоваяСтрока[ИмяКолонки] = ЗначениеЯчейки;
                            // Используется при формировании таблицы на форме обработки.
                            ШиринаКолонки = ТаблицаРезультат.Колонки[ИмяКолонки].Ширина;
                            ДлинаСтроки = СтрДлина(СокрЛП(ЗначениеЯчейки));
                            ТаблицаРезультат.Колонки[ИмяКолонки].Ширина = ?(ШиринаКолонки < ДлинаСтроки, ДлинаСтроки, ШиринаКолонки);
                           
                        КонецЕсли;
                    КонецЕсли;
                КонецЕсли;
            КонецЦикла;
            Если НЕ КонСтрока = 0 И ((НомерСтроки + 1) > КонСтрока) Тогда
                Прервать;   // Окончание диапазона считываемых данных.
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
   
    // Завершение работы.
    // Закрытие Объектов.
    SheetX.Закрыть();
   
    хмл_УдалитьКолонкиСНулевойШириной(ТаблицаРезультат);
   
    Возврат ТаблицаРезультат;
   
КонецФункции


Функция хмл_ИзвлечьДанныеИзФайла_StylesXML(ZIPКаталог, СоответствиеNumFmtIdFormatCode)
    Перем Файл, Styles;
    Перем МассивNumFmtId, ит;
   
    МассивNumFmtId = Новый Массив;
    СоответствиеNumFmtIdFormatCode = Новый Соответствие;
   
    Файл = Новый Файл(ZIPКаталог + "XL\Styles.xml");
    Если НЕ Файл.Существует() Тогда
        Возврат МассивNumFmtId;
    КонецЕсли;
   
    Styles = Новый ЧтениеXML;
    Styles.ОткрытьФайл(Файл.ПолноеИмя);
   
    Пока Styles.Прочитать() Цикл
        Если ВРег(Styles.Имя) = ВРег("numFmt") И Styles.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            СоответствиеNumFmtIdFormatCode.Вставить(Styles.ЗначениеАтрибута("numFmtId"), ВРег(Styles.ЗначениеАтрибута("formatCode")));
        КонецЕсли;
        Если ВРег(Styles.Имя) = ВРег("cellXfs") Тогда
            Пока Styles.Прочитать() Цикл
                Если ВРег(Styles.Имя) = ВРег("xf") И Styles.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
                    МассивNumFmtId.Добавить(Styles.ЗначениеАтрибута("numFmtId"));
                КонецЕсли;
            КонецЦикла;
        КонецЕсли;
    КонецЦикла;
   
    // Завершение работы.
    // Закрытие Объектов.
    Styles.Закрыть();

    // Проверка сопоставления кодов массива и соответствия.
    // MS Office может не формировать в xml-файле описание стиля форматирования для ячейки.
    // LibreOffice формирует в xml-файле необходимые описания стиля форматирования ячейки.
    Для Каждого ит ИЗ МассивNumFmtId Цикл
        Если СоответствиеNumFmtIdFormatCode.Получить(ит) = Неопределено Тогда
            Если ит = "0" Тогда    // Стандарт для числа (Целое число).
                СоответствиеNumFmtIdFormatCode.Вставить(ит, "GENERAL");
            ИначеЕсли ит = "9" ИЛИ ит = "10" Тогда    // Форматы для % ("0%", "0.00%").
                СоответствиеNumFmtIdFormatCode.Вставить(ит, "0%");
            ИначеЕсли ит = "14" ИЛИ ит = "16" Тогда    // Форматы для даты.
                СоответствиеNumFmtIdFormatCode.Вставить(ит, "DD.MM.YYYY");
            ИначеЕсли ит = "45" ИЛИ ит = "46" ИЛИ ит = "47" Тогда    // Форматы для времени.
                СоответствиеNumFmtIdFormatCode.Вставить(ит, "HH:MM:SS");
            КонецЕсли;
        КонецЕсли;
    КонецЦикла;
   
    Возврат МассивNumFmtId;
   
КонецФункции

Функция хмл_ИзвлечьДанныеИзФайла_SharedStringsXML(ZIPКаталог)
    Перем Файл, SharedStrings;
    Перем МассивSharedStrings;
   
    // Если в файле EXCEL не содержится значений, имеющих тип "СТРОКА", то файл "SharedStrings.xml" не формируется.
   
    МассивSharedStrings = Новый Массив;
   
    Файл = Новый Файл(ZIPКаталог + "XL\SharedStrings.xml");
    Если НЕ Файл.Существует() Тогда
        Возврат МассивSharedStrings;
    КонецЕсли;
   
    SharedStrings = Новый ЧтениеXML;
    SharedStrings.ОткрытьФайл(Файл.ПолноеИмя);
   
    Пока SharedStrings.Прочитать() Цикл
        Если ВРег(SharedStrings.Имя) = "#TEXT" Тогда
            МассивSharedStrings.Добавить(SharedStrings.Значение);
        КонецЕсли;
    КонецЦикла;
   
    // Завершение работы.
    // Закрытие Объектов.
    SharedStrings.Закрыть();
   
    Возврат МассивSharedStrings;
   
КонецФункции

Функция хмл_ПолучитьМассивИменКолонокНаЛистеXLSX(SheetX)
    Перем ДиапазонДанных, ДиапазонКолонок, ПерваяКолонка, ПоследняяКолонка, НомерПервойК, НомерПоследнейК;
    Перем Подсчет, ИмяКолонки;
    Перем МассивИменКолонокXLSX, КолвоКолонокEXCEL;
    
    МассивИменКолонокXLSX = Новый Массив;
    
    Подсчет = Ложь;
    // Считать очередной узел XML.
    Пока SheetX.Прочитать() Цикл
        // DIMENSION.
        Если ВРег(SheetX.Имя) = "DIMENSION" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
            ДиапазонДанных     = SheetX.ПолучитьАтрибут("ref");
            ДиапазонКолонок = хмл_ЗаменитьОдниСимволыДругими("0123456789", ДиапазонДанных, "");
            ПерваяКолонка     = Лев(ДиапазонКолонок, Найти(ДиапазонКолонок ,":") - 1);
            ПоследняяКолонка= Сред(ДиапазонКолонок, Найти(ДиапазонКолонок ,":") + 1);
            НомерПервойК    = хмл_НомерКолонкиДесятичный(ПерваяКолонка);
            НомерПоследнейК    = хмл_НомерКолонкиДесятичный(ПоследняяКолонка);
        КонецЕсли;
		// Подсчет по 1-ой строке.
		Если ВРег(SheetX.Имя) = "ROW" Тогда
		    Если SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
		        // Начало отсчета.
		        Подсчет = Истина;
		    ИначеЕсли SheetX.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
		        // Окончание отсчета.
		        Прервать;
		    КонецЕсли;
		КонецЕсли;
		Если Подсчет И ВРег(SheetX.Имя) = "C" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
		    ИмяКолонки = SheetX.ПолучитьАтрибут("r");
		    ИмяКолонки = хмл_ЗаменитьОдниСимволыДругими("0123456789", ИмяКолонки, "");
		    МассивИменКолонокXLSX.Добавить(ИмяКолонки);
		КонецЕсли;
    КонецЦикла;
	
	//хмл_ДополнитьМассивИменКолонокXLSX(НомерПоследнейК, МассивИменКолонокXLSX);
	
	КолвоКолонокEXCEL = МассивИменКолонокXLSX.Количество();
	Если НЕ НомерПоследнейК = Неопределено Тогда
	    Если КолвоКолонокEXCEL < НомерПоследнейК Тогда
			//Сообщить("Строка заголовков колонок (1-я строка) заполнена не полностью:
			//|К-во колонок строки меньше объявленной: " + КолвоКолонокEXCEL + "<" + НомерПоследнейК);
	        хмл_ДополнитьМассивИменКолонокXLSX(НомерПоследнейК, МассивИменКолонокXLSX);
	    ИначеЕсли КолвоКолонокEXCEL > НомерПоследнейК Тогда
	        Сообщить("Строка заголовков колонок (1-я строка) содержит больше колонок, чем объявлено:
	        |К-во колонок строки больше объявленной:" + КолвоКолонокEXCEL + ">" + НомерПоследнейК);
	    КонецЕсли;
	КонецЕсли;
        
    Возврат МассивИменКолонокXLSX;
    
КонецФункции

Функция хмл_НомерКолонкиДесятичный(ИмяКолонкиXLSX)
    Перем Латиница, ДлинаНомера, Поз, ит;
    Перем НомерКолонки;
    
    Латиница = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";    // 26.
    ДлинаНомера = СтрДлина(ИмяКолонкиXLSX);
    НомерКолонки = 0;
    Для ит = 1 ПО ДлинаНомера Цикл
        Поз = Найти(Латиница, Сред(ИмяКолонкиXLSX, (ДлинаНомера + 1 - ит), 1));
        НомерКолонки = НомерКолонки + Поз * Pow(26, ит - 1);
    КонецЦикла;
    
    Возврат НомерКолонки;
    
КонецФункции

Процедура хмл_ДополнитьМассивИменКолонокXLSX(Знач КолвоКолонокExcel, МассивИменКолонокXLSX, Индекс = - 1)
    Перем Алфавит, ит, Буква;
    
    Алфавит = хмл_РазложитьСтрокуВМассивПодстрок("A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z", ",");
    
    Если МассивИменКолонокXLSX.Количество() >= КолвоКолонокExcel Тогда
        Возврат;
    КонецЕсли;
    
    Если Индекс > Алфавит.Количество() - 1 Тогда
        Возврат;
    КонецЕсли;
    
    Буква = ?(Индекс = -1, "", Алфавит[Индекс]);
    Для ит = 0 ПО Алфавит.Количество() - 1 Цикл
        Если МассивИменКолонокXLSX.Найти(Буква + Алфавит[ит]) = Неопределено Тогда
            МассивИменКолонокXLSX.Добавить(Буква + Алфавит[ит]);
        КонецЕсли;
        Если МассивИменКолонокXLSX.Количество() >= КолвоКолонокExcel Тогда
            Возврат;
        КонецЕсли;
    КонецЦикла;
    
    Если МассивИменКолонокXLSX.Количество() > КолвоКолонокExcel Тогда
        Возврат;
    Иначе
        Индекс = Индекс + 1;
        хмл_ДополнитьМассивИменКолонокXLSX(КолвоКолонокExcel, МассивИменКолонокXLSX, Индекс);
    КонецЕсли;
    
    Возврат;
    
КонецПроцедуры

// Функция "расщепляет" строку на подстроки, используя заданный
//      разделитель. Разделитель может иметь любую длину.
//      Если в качестве разделителя задан пробел, рядом стоящие пробелы
//      считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//      игнорируются.
//      Например,
//      РазложитьСтрокуВМассивПодстрок(",один,,,два", ",") возвратит массив значений из пяти элементов,
//      три из которых - пустые строки, а
//      РазложитьСтрокуВМассивПодстрок(" один   два", " ") возвратит массив значений из двух элементов
//
//  Параметры:
//      Стр -           строка, которую необходимо разложить на подстроки.
//                      Параметр передается по значению.
//      Разделитель -   строка-разделитель, по умолчанию - запятая.
//
//  Возвращаемое значение:
//      массив значений, элементы которого - подстроки
//
Функция хмл_РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",")
    
    МассивСтрок = Новый Массив();
    Если Разделитель = " " Тогда
        Стр = СокрЛП(Стр);
        Пока 1 = 1 Цикл
            Поз = Найти(Стр, Разделитель);
            Если Поз = 0 Тогда
                МассивСтрок.Добавить(СокрЛП(Стр));
                Возврат МассивСтрок;
            КонецЕсли;
            МассивСтрок.Добавить(СокрЛП(Лев(Стр, Поз - 1)));
            Стр = СокрЛ(Сред(Стр, Поз));
        КонецЦикла;
    Иначе
        ДлинаРазделителя = СтрДлина(Разделитель);
        Пока 1 = 1 Цикл
            Поз = Найти(Стр, Разделитель);
            Если Поз = 0 Тогда
                Если (СокрЛП(Стр) <> "") Тогда
                    МассивСтрок.Добавить(СокрЛП(Стр));
                КонецЕсли;
                Возврат МассивСтрок;
            КонецЕсли;
            МассивСтрок.Добавить(СокрЛП(Лев(Стр,Поз - 1)));
            Стр = Сред(Стр, Поз + ДлинаРазделителя);
        КонецЦикла;
    КонецЕсли;
   
КонецФункции

Функция хмл_ЭтоЧислоXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
   
    Если ( ВРег(ФорматСтиля) = "GENERAL"
        ИЛИ ВРег(ФорматСтиля) = "STANDARD"
        ИЛИ Найти(ФорматСтиля, "0") > 0 )
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_ЭтоПроцентXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
   
    Если ( Найти(ФорматСтиля, "%") > 0 )
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_ЭтоБулевоXLSX(ЗначениеЯчейки, ФорматСтиля)
   
    Если (ЗначениеЯчейки = 0 ИЛИ ЗначениеЯчейки = 1)
        И Найти(ВРег(ФорматСтиля), "ИСТИНА") > 0 ИЛИ Найти(ВРег(ФорматСтиля), "ЛОЖЬ") > 0
        ИЛИ Найти(ВРег(ФорматСтиля), "TRUE") > 0 ИЛИ Найти(ВРег(ФорматСтиля), "FALSE") > 0
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_ЭтоДатаXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
   
    Если ЗначениеЯчейки = Цел(ЗначениеЯчейки) И
        ( Найти(ФорматСтиля, "DD") > 0
        ИЛИ Найти(ФорматСтиля, "MM") > 0
        ИЛИ Найти(ФорматСтиля, "YY") > 0
        ИЛИ Найти(ФорматСтиля, "QQ") > 0
        ИЛИ Найти(ФорматСтиля, "WW") > 0 )
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_ЭтоВремяXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
   
    Если ЗначениеЯчейки < 1 И
        ( Найти(ФорматСтиля, "HH:") > 0
        ИЛИ Найти(ФорматСтиля, "[HH]:") > 0
        ИЛИ Найти(ФорматСтиля, "[H]:") > 0
        ИЛИ Найти(ФорматСтиля, "MM:") > 0
        ИЛИ Найти(ФорматСтиля, ":SS") > 0 )
        Тогда
        Возврат Истина;
    КонецЕсли;
   
    Возврат Ложь;
   
КонецФункции

Функция хмл_КонвертироватьЧислоXLSXвДату(Знач Число)
    Перем Дата1900, Разница, ДатаРезультат;
   
    Дата1900 = Дата("19000101");
   
    Разница = Число - 2;    // EXCEL ошибочно считает 1900-й год високосным.
    Разница = ?(Разница < 0, 0, Разница);
   
    ДатаРезультат = Дата1900 + Разница * 24 * 60 * 60;
   
    Возврат ДатаРезультат;
   
КонецФункции

Функция хмл_КонвертироватьЧислоXLSXвДатуВремя(Знач Число)
    Перем КВоСекунд;
    Перем ВремяРезультат;
   
    // 0,0000115740740740741 = 1 сек.
    // 1                     = 24 часа 00 мин 00 сек.
   
    Если ТипЗнч(Число) = Тип("Число") Тогда
        КВоСекунд = Число * 100000 / 1.15740740740741;
        КВоСекунд = Окр(КВоСекунд);
    Иначе
        Сообщить("Ошибка определения значения типа ""Время"".");
    КонецЕсли;
   
    ВремяРезультат = Дата("19000101000000") + КВоСекунд;
   
    Возврат ВремяРезультат;
   
КонецФункции

Функция хмл_ПолучитьЧислоВСтепениИзСтроковогоЗначения(Знач ЗначениеЯчейки)
    Перем Поз1Е, Степень;
    Перем Значение;
   
    Если Найти(ЗначениеЯчейки, "E-") > 0 Тогда
        Поз1Е = Найти(ЗначениеЯчейки, "E-");
        Степень = Сред(ЗначениеЯчейки, Поз1Е+2);
        Значение = Лев(ЗначениеЯчейки, Поз1Е-1);
        Попытка
            Степень = Число(Степень);
            Значение = Число(Значение) / Pow(10, Степень);
        Исключение
            Значение = ЗначениеЯчейки;
        КонецПопытки;
    ИначеЕсли Найти(ЗначениеЯчейки, "E+") > 0 Тогда
        Поз1Е = Найти(ЗначениеЯчейки, "E+");
        Степень = Сред(ЗначениеЯчейки, Поз1Е+2);
        Значение = Лев(ЗначениеЯчейки, Поз1Е-1);
        Попытка
            Степень = Число(Степень);
            Значение = Число(Значение) * Pow(10, Степень);
        Исключение
            Значение = ЗначениеЯчейки;
        КонецПопытки;
    Иначе
        Значение = ЗначениеЯчейки;
    КонецЕсли;
   
    Возврат Значение;
   
КонецФункции

Функция хмл_ЗаменитьОдниСимволыДругими(ЗаменяемыеСимволы, Строка, СимволыЗамены)
    Результат = Строка;
    Для НомерСимвола = 1 По СтрДлина(ЗаменяемыеСимволы) Цикл
        Результат = СтрЗаменить(Результат, Сред(ЗаменяемыеСимволы, НомерСимвола, 1), Сред(СимволыЗамены, НомерСимвола, 1));
    КонецЦикла;
    Возврат Результат;
КонецФункции

Процедура хмл_УдалитьКолонкиСНулевойШириной(ТаблицаРезультат)
    Перем МассивПустыхКолонок;
    // Найдем пустые колонки.
    МассивПустыхКолонок = Новый Массив;
    Для Каждого Колонка ИЗ ТаблицаРезультат.Колонки Цикл
        Если Колонка.Ширина = 0 Тогда
            МассивПустыхКолонок.Добавить(Колонка.Имя);
        КонецЕсли;
    КонецЦикла;
    // Удалим пустые колонки.
    Для Каждого ПустаяКолонка ИЗ МассивПустыхКолонок Цикл
        ТаблицаРезультат.Колонки.Удалить(ПустаяКолонка);
    КонецЦикла;
КонецПроцедуры


////запись через XML////
Процедура ОбработатьЯчейкуСДанными(СтараяВерсияXML, НоваяВерсияXML, ЯчейкиКЗамене, флПродолжить)
	
	Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.НачалоЭлемента И ВРег(СтараяВерсияXML.Имя) = "C" Тогда
		флПродолжить = Истина;
		флЯчейкаКЗамене = Ложь;
		НовоеЗначение = 0;
		
		ИмяКолонки = СтараяВерсияXML.ЗначениеАтрибута("r");					
		Если ЯчейкиКЗамене[ИмяКолонки] <> Неопределено Тогда
			НовоеЗначение = ЯчейкиКЗамене[ИмяКолонки];
			флЯчейкаКЗамене = Истина;	
		КонецЕсли;
		
		НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
		Пока СтараяВерсияXML.ПрочитатьАтрибут() Цикл
			НоваяВерсияXML.ЗаписатьАтрибут(СтараяВерсияXML.Имя, СтараяВерсияXML.Значение);				
		КонецЦикла;
		
		СтараяВерсияXML.Прочитать();
		
		//элемент "С" имеет пустое значение 
		//добавляем значение, если ячейка к замене
		Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ВРег(СтараяВерсияXML.Имя) = "C" Тогда
			//добавляем значение
			Если флЯчейкаКЗамене Тогда
				НоваяВерсияXML.ЗаписатьНачалоЭлемента("v");
				НоваяВерсияXML.ЗаписатьТекст(НовоеЗначение);
				НоваяВерсияXML.ЗаписатьКонецЭлемента();
			КонецЕсли;
			
			//записываем значение элемента "С"
			НоваяВерсияXML.ЗаписатьКонецЭлемента();
			
			Возврат; //пустая ячейка
		КонецЕсли;	
		
		//элемент "С" без формул
		//подменяем значение, если ячейка к замене
		Если ВРег(СтараяВерсияXML.Имя) = "V" Тогда
			Если флЯчейкаКЗамене Тогда
				НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
				НоваяВерсияXML.ЗаписатьТекст(НовоеЗначение);
				НоваяВерсияXML.ЗаписатьКонецЭлемента();
				
				Пока СтараяВерсияXML.Прочитать() Цикл
					Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
						Прервать;
					КонецЕсли;
				КонецЦикла;
			Иначе
				НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
				СтараяВерсияXML.Прочитать();
				Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.Текст Тогда
					НоваяВерсияXML.ЗаписатьТекст(СтараяВерсияXML.Значение);
					СтараяВерсияXML.Прочитать();
					НоваяВерсияXML.ЗаписатьКонецЭлемента();
				ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
					НоваяВерсияXML.ЗаписатьКонецЭлемента();	
				КонецЕсли;
			КонецЕсли;
			
			//прочитаем и запишем конец элемента "С"
			СтараяВерсияXML.Прочитать();
			НоваяВерсияXML.ЗаписатьКонецЭлемента();
			
			Возврат;
		КонецЕсли;
		
		//элемент "С" с формулой
		//данные из элемента "F" переносим
		//данные из элемента "V" очищаем, чтобы при открытии экселя значения формул пересчитались
		Если ВРег(СтараяВерсияXML.Имя) = "F" Тогда
			НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
			Пока СтараяВерсияXML.ПрочитатьАтрибут() Цикл
				НоваяВерсияXML.ЗаписатьАтрибут(СтараяВерсияXML.Имя, СтараяВерсияXML.Значение);				
			КонецЦикла;
		
			СтараяВерсияXML.Прочитать();
			Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.Текст Тогда
				НоваяВерсияXML.ЗаписатьТекст(СтараяВерсияXML.Значение);
				СтараяВерсияXML.Прочитать();
				НоваяВерсияXML.ЗаписатьКонецЭлемента();
			ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
				НоваяВерсияXML.ЗаписатьКонецЭлемента();	
			КонецЕсли;	
		 
			СтараяВерсияXML.Прочитать();
			//элемент "V" пропускаем и не записываем
			Если ВРег(СтараяВерсияXML.Имя) = "V" Тогда
				Пока СтараяВерсияXML.Прочитать() Цикл
					Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
						СтараяВерсияXML.Прочитать();
						Прервать;
					КонецЕсли;
				КонецЦикла;
			Иначе
				а=1;
			КонецЕсли;
			
			//записываем значение элемента "С"
			НоваяВерсияXML.ЗаписатьКонецЭлемента();
			
			//читаем след строку, чтобы правильно отработала логика процедуре из которой вызвали
			Возврат;
		КонецЕсли;	
	КонецЕсли;
	
КонецПроцедуры

Функция хмл_ИзменитьДанныеЯчеекНаЛисте(ПутьКФайлуИсточнику, ИмяНомерЛиста, ЯчейкиКЗамене) Экспорт

	//ЯчейкиКЗамене = Новый Соответствие;
	//Ключ - Это имя ячейки в Excel файла (А1, В2 и т.п.)
	//Значение - новое значение, которое нужно записать в файл

	ОтветФункции = Новый Структура;
	ОтветФункции.Вставить("Результат", Ложь);
	ОтветФункции.Вставить("ОписаниеОшибки", "");
	ОтветФункции.Вставить("ПутьКФайлуИсточнику", ПутьКФайлуИсточнику);
	ОтветФункции.Вставить("ПутьКФайлуПриемнику", "");
	
	//проверяем файл эксель и распаковываем, как архив
	КаталогZIP = КаталогВременныхФайлов() + "XLSX\";
	ОтветРаспаковки = хмл_ИзвлечьXLSXВКаталогZIP(ПутьКФайлуИсточнику, КаталогZIP);
	Если ОтветРаспаковки.Результат = Ложь Тогда
		ОтветФункции.ОписаниеОшибки = ОтветРаспаковки.ОписаниеОшибки;
		
		Возврат ОтветФункции;
	КонецЕсли;
	
	//инициализация переменных
	ФайлНомерЛиста  = ИмяНомерЛиста.НомерЛиста;
    ФайлНомерЛиста = ?(ФайлНомерЛиста = 0, 1, ФайлНомерЛиста);
	
	ИмяФайлаЛиста = "Sheet" + ФайлНомерЛиста + ".xml"; 
	КаталогЛистов = "XL\WorkSheets\";
	ПутьКфайлуЛиста = КаталогZIP + КаталогЛистов + ИмяФайлаЛиста;
	
	//копируем xml, чтоб избежать блокировки файла, в который будем новые данные писать
	ПутьККопииФайлаЛиста = ПолучитьИмяВременногоФайла("xml");
	КопироватьФайл(ПутьКфайлуЛиста, ПутьККопииФайлаЛиста);
	
	//основной код
	//читаем построчно копию файла листа, подменяем данные и записываем в основной файл листа
	СтараяВерсияXML = Новый ЧтениеXML;
    СтараяВерсияXML.ОткрытьФайл(ПутьККопииФайлаЛиста);
	
	НоваяВерсияXML = Новый ЗаписьXML;
	НоваяВерсияXML.ОткрытьФайл(ПутьКфайлуЛиста);
	НоваяВерсияXML.ЗаписатьОбъявлениеXML();
	
	Пока СтараяВерсияXML.Прочитать() Цикл
		флПродолжить = Ложь;
		ОбработатьЯчейкуСДанными(СтараяВерсияXML, НоваяВерсияXML, ЯчейкиКЗамене, флПродолжить);
		Если флПродолжить Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтараяВерсияXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда			
			НоваяВерсияXML.ЗаписатьНачалоЭлемента(СтараяВерсияXML.Имя);
			Пока СтараяВерсияXML.ПрочитатьАтрибут() Цикл
				НоваяВерсияXML.ЗаписатьАтрибут(СтараяВерсияXML.Имя, СтараяВерсияXML.Значение);				
			КонецЦикла;
		ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.Текст Тогда
			НоваяВерсияXML.ЗаписатьТекст(СтараяВерсияXML.Значение);				
		ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			НоваяВерсияXML.ЗаписатьКонецЭлемента();				
		ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.ИнструкцияОбработки Тогда
			НоваяВерсияXML.ЗаписатьИнструкциюОбработки(СтараяВерсияXML.Имя, СтараяВерсияXML.Значение);
		ИначеЕсли СтараяВерсияXML.ТипУзла = ТипУзлаXML.Комментарий Тогда
			НоваяВерсияXML.ЗаписатьКомментарий(СтараяВерсияXML.Значение);		
		КонецЕсли;
	КонецЦикла;
	НоваяВерсияXML.Закрыть();
	
	//запаковыем измененные данные обратно в xlsx
	ПутьКФайлуПриемнику = ПолучитьИмяВременногоФайла("xlsx");
	хмл_ЗапаковатьКаталогВXLSX(ПутьКФайлуПриемнику, КаталогZIP);
	ОтветФункции.ПутьКФайлуПриемнику = ПутьКФайлуПриемнику;
	
	//
	УдалитьФайлы(КаталогZIP);
	ОтветФункции.Результат = Истина;
	Возврат ОтветФункции;
	
КонецФункции

////Работа с архиватором////
Функция хмл_ИзвлечьXLSXВКаталогZIP(ПутьКФайлуXLSX, КаталогZIP)

	ОтветФункции = Новый Структура;
	ОтветФункции.Вставить("Результат", Ложь);
	ОтветФункции.Вставить("ОписаниеОшибки", "");
	ОтветФункции.Вставить("ПутьКФайлуXLSX", ПутьКФайлуXLSX);
	ОтветФункции.Вставить("КаталогZIP", КаталогZIP);
	
	Если НЕ ЗначениеЗаполнено(ПутьКФайлуXLSX) Тогда
		ОтветФункции.ОписаниеОшибки = "Файл не найден, т.к. передан пустой путь к файлу XLSX";
		
		Возврат ОтветФункции;
    КонецЕсли;
   
    ФайлXLSX = Новый Файл(ПутьКФайлуXLSX);
	Если НЕ ФайлXLSX.Существует() Тогда
		ТекстОшибки = "Файл не существует. Путь к файлу: %1";
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, ПутьКФайлуXLSX);
		
		Возврат ОтветФункции;
	КонецЕсли;
	
	Если НЕ ВРег(ФайлXLSX.Расширение) = ".XLSX" Тогда		
		ТекстОшибки = "Файл с расширением %1 не поддерживается методом NativeXLSX: %2";;
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, ФайлXLSX.Расширение, ПутьКФайлуXLSX);
		
		Возврат ОтветФункции;
	КонецЕсли;
	
	Попытка
		ПереместитьФайл(ФайлXLSX.ПолноеИмя,ФайлXLSX.ПолноеИмя);
	Исключение
		ТекстОшибки = "Файл занят другим процессом. Описание ошибки: %1";
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		Возврат ОтветФункции;
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(КаталогZIP);
		
		ZIPФайл = Новый ЧтениеZipФайла;
		ZIPФайл.Открыть(ПутьКФайлуXLSX);
		ZIPФайл.ИзвлечьВсе(КаталогZIP, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Исключение
		ТекстОшибки = "Не удалось распаковать файл. Описание ошибки: %1";
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		Возврат ОтветФункции;
	КонецПопытки;
	
	ОтветФункции.Результат = Истина;
	Возврат ОтветФункции;
	
КонецФункции

Функция хмл_ЗапаковатьКаталогВXLSX(ПутьКФайлуXLSX, КаталогZIP)

	ОтветФункции = Новый Структура;
	ОтветФункции.Вставить("Результат", Ложь);
	ОтветФункции.Вставить("ОписаниеОшибки", "");
	
	Попытка
		ЗипФайл = Новый ЗаписьZipФайла;
		ЗипФайл.Открыть(ПутьКФайлуXLSX);
		ЗипФайл.Добавить(КаталогZIP+"*", РежимСохраненияПутейZIP.СохранятьОтносительныеПути, РежимОбработкиПодкаталоговZIP.ОбрабатыватьРекурсивно);	
		ЗипФайл.Записать();
	Исключение
		ТекстОшибки = "Не удалось запаковать файл. Описание ошибки: %1";
		ОтветФункции.ОписаниеОшибки = СтрШаблон(ТекстОшибки, КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		Возврат ОтветФункции;
	КонецПопытки;

	ОтветФункции.Результат = Истина;
	Возврат ОтветФункции;
	
КонецФункции
